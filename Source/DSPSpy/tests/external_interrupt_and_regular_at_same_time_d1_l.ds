; This test needs to manually specify IRQs
	jmp		irq0
	jmp		irq1
	jmp		irq2
	jmp		irq3
	jmp		irq4
	jmp		accov_irq
	jmp		irq6
	jmp		external_irq

incdir  "tests"
include "dsp_base_noirq.inc"

test_main:
	; Use the accelerator to generate an IRQ by setting the start and end address to 0
	; This will result in an interrupt on every read
	SI @0xffda, #0 ; pred_scale
	SI @0xffdb, #0 ; yn1
	SI @0xffdc, #0 ; yn2
	SI @0xffd1, #0 ; SampleFormat
	SI @ACSAH, #0
	SI @ACCAH, #0
	SI @ACSAL, #0
	SI @ACCAL, #0
	SI @ACEAH, #0
	SI @ACEAL, #0

	CLR $ACC0
	CLR $ACC1
	SBCLR #2
	SBSET #3
	SBCLR #4
	SBCLR #5
	SBCLR #6

	LRIS $AX1.H, #1

	LRIS $AX0.H, #1
	CALL send_back

	SI @DMBH, #0x8888
	SI @DMBL, #0x5371

wait_cpu_read:
	LRS $AC1.M, @DMBH
	ANDCF $AC1.M, #0x8000
	JLZ wait_cpu_read

	CLR $ACC1
second_loop:
	INC $ACC1
	CMPIS $AC1.M, #1
	JNZ second_loop

	SBSET #6
	SBSET #5
	; Trigger an interrupt 1 instruction after external interrupts become enabled
	; However, LRI is used instead of LRIS, and LRI takes 2 words
	LRI $AX1.H, #2
	LRS $AX0.L, @ARAM
	LRIS $AX1.H, #3
	LRIS $AX1.H, #4
	LRIS $AX1.H, #5
	LRIS $AX1.H, #6

	LRIS $AX0.H, #2
	CALL send_back

	JMP end_of_test

accov_irq:
	INC $ACC0
	INCM $AC0.M

	; Restore registers, otherwise no new interrupt will be generated
	SI @0xffda, #0 ; pred_scale
	SI @0xffdb, #0 ; yn1
	SI @0xffdc, #0 ; yn2

	LRIS $AX0.H, #3
	CALL send_back

	DECM $AC0.M
	RTI

external_irq:
	INC $ACC0
	INCM $AC0.M

	LRIS $AX0.H, #4
	CALL send_back

	DECM $AC0.M
	RTI

; Expected result ($AX0.H (send_back num), $AX1.H, $AC0.L (interrupt count), $AC0.M (interrupt depth), and $SR):
; 1, 1, 0, 0, 2224 (start)
; 4, 2, 1, 1, 2a20 (external interrupt - comes first this time, so LRI takes twice as long as LRS)
; 3, 2, 2, 1, 2a20 (overflow interrupt - comes after, when the LRS instruction occurs)
; 2, 6, 2, 0, 3a25 (end)
