// Copyright (C) 2003 Dolphin Project.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, version 2.0.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License 2.0 for more details.

// A copy of the GPL 2.0 should have been included with the program.
// If not, see http://www.gnu.org/licenses/

// Official SVN repository and contact information can be found at
// http://code.google.com/p/dolphin-emu/

#ifndef _EFBCOPY_H
#define _EFBCOPY_H

#include "VideoCommon.h"

// 4-bit format: 8x8 texels / cache line
// 8-bit format: 8x4 texels / cache line
// 16-bit format: 4x4 texels / cache line
// 32-bit format: 4x4 texels / 2 cache lines
// Compressed format: 8x8 texels / cache line

// Document EFB encoding formats here with examples of where they are used.

// Format: 0 - R4
// Used in The Legend of Zelda: The Wind Waker for character shadows (srcFormat 1,
// isIntensity 1, scaleByHalf 1).

// Format: 1 - R8
// Used in Metroid Prime for the thermal visor. May or may not be a duplicate
// of format 8.

// Format: 2 - A4 R4
// FIXME: Unseen.

// Format: 3 - A8 R8
// FIXME: Unseen.

// Format: 4 - R5 G6 B5
// Used in Wind Waker for most render-to-texture effects like heat shimmer and
// depth-of-field.

// Format: 5 - 1 R5 G5 B5 or 0 A3 R4 G4 B4
// Used in Twilight Princess for character shadows.

// Format: 6 - A8 R8 A8 R8 | G8 B8 G8 B8
// Used in Twilight Princess for bloom effect.

// Format: 7 - A8
// Used in Metroid Prime 2 for the scan visor.

// Format: 8 - R8
// Used in Twilight Princess for the map.

// Format: 9 - G8
// FIXME: Unseen.

// Format: A - B8
// Used in Metroid Prime 2 for the scan visor.

// Format: B - G8 R8
// Used in Wind Waker for depth-of-field. Usually used with srcFormat 3 to
// render depth textures. The bytes are swapped, so games have to correct it
// in RAM before using it as a texture.

// Format: C - B8 G8
// FIXME: Unseen.

// EFB copy destination formats. These names are guesses. If the depth buffer
// is used as the source, the X8 Z24 data is translated to A8 R8 G8 B8 and
// encoded just like the color buffer.
enum EFBCopyFormat
{
	EFB_COPY_R4     = 0x0,
	EFB_COPY_R8_1   = 0x1, // FIXME: Is this the same as 0x8?
	EFB_COPY_RA4    = 0x2,
	EFB_COPY_RA8    = 0x3,
	EFB_COPY_RGB565 = 0x4,
	EFB_COPY_RGB5A3 = 0x5,
	EFB_COPY_RGBA8  = 0x6,
	EFB_COPY_A8     = 0x7,
	EFB_COPY_R8     = 0x8,
	EFB_COPY_G8     = 0x9,
	EFB_COPY_B8     = 0xA,
	EFB_COPY_RG8    = 0xB,
	EFB_COPY_GB8    = 0xC
};

extern const unsigned int EFB_COPY_BLOCK_WIDTHS[];
extern const unsigned int EFB_COPY_BLOCK_HEIGHTS[];

// Maximum number of bytes that can occur in a texture block-row generated by
// the encoder
static const size_t EFB_COPY_MAX_BYTES_PER_ROW = (EFB_WIDTH/4)*64;
// The maximum amount of data that the texture encoder can generate in one call
static const size_t EFB_COPY_MAX_BYTES = EFB_COPY_MAX_BYTES_PER_ROW*(EFB_HEIGHT/4);

#endif
