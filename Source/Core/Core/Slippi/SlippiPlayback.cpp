#include <memory>
#include <mutex>

#ifdef _WIN32
#include <share.h>
#endif

#include "Common/CommonPaths.h"
#include "Common/Config/Config.h"
#include "Common/FileUtil.h"
#include "Common/Logging/Log.h"
#include "Core/Config/MainSettings.h"
#include "Core/Core.h"
#include "Core/HW/EXI/EXI_DeviceSlippi.h"
#include "Core/NetPlayClient.h"
#include "Core/State.h"
#include "Core/System.h"
#include "SlippiPlayback.h"

#define FRAME_INTERVAL 900
#define SLEEP_TIME_MS 8

std::unique_ptr<SlippiPlaybackStatus> g_playback_status;
extern std::unique_ptr<SlippiReplayComm> g_replay_comm;

static std::mutex mtx;
static std::mutex seek_mtx;
static std::mutex ffw_mtx;
static std::mutex diff_mtx;
static std::unique_lock<std::mutex> processing_lock(diff_mtx);
static std::condition_variable cond_var;
static std::condition_variable cv_waiting_for_target_frame;
static std::condition_variable cv_processing_diff;
static std::atomic<int> num_diffs_processing(0);

s32 emod(s32 a, s32 b)
{
  assert(b != 0);
  int r = a % b;
  return r >= 0 ? r : r + std::abs(b);
}

std::string processDiff(std::vector<u8> initial_state, std::vector<u8> curr_state)
{
  INFO_LOG_FMT(SLIPPI, "Processing diff");
  num_diffs_processing += 1;
  cv_processing_diff.notify_one();
  std::string diff = std::string();
  open_vcdiff::VCDiffEncoder encoder((char*)initial_state.data(), initial_state.size());
  encoder.Encode((char*)curr_state.data(), curr_state.size(), &diff);

  INFO_LOG_FMT(SLIPPI, "done processing");
  num_diffs_processing -= 1;
  cv_processing_diff.notify_one();
  return diff;
}

SlippiPlaybackStatus::SlippiPlaybackStatus()
{
  should_jump_back = false;
  should_jump_forward = false;
  in_slippi_playback = false;
  should_run_threads = false;
  is_hard_FFW = false;
  is_soft_FFW = false;
  last_FFW_frame = INT_MIN;
  current_playback_frame = INT_MIN;
  target_frame_num = INT_MAX;
  last_frame = Slippi::PLAYBACK_FIRST_SAVE;
#ifdef IS_PLAYBACK
  // Only generate these if this is a playback configuration. Should this class get initialized at
  // all?
  generateDenylist();
  generateLegacyCodelist();
#endif
}

void SlippiPlaybackStatus::startThreads()
{
  should_run_threads = true;
  m_savestate_thread = std::thread(&SlippiPlaybackStatus::SavestateThread, this);
}

void SlippiPlaybackStatus::prepareSlippiPlayback(s32& frame_idx)
{
  // block if there's too many diffs being processed
  while (should_run_threads && num_diffs_processing > 2)
  {
    INFO_LOG_FMT(SLIPPI, "Processing too many diffs, blocking main process");
    cv_processing_diff.wait(processing_lock);
  }

  // Unblock thread to save a state every interval
  if (should_run_threads && ((current_playback_frame + 122) % FRAME_INTERVAL == 0))
    cond_var.notify_one();

  // TODO: figure out why sometimes playback frame increments past target_frame_num
  if (in_slippi_playback && frame_idx >= target_frame_num)
  {
    INFO_LOG_FMT(SLIPPI, "Reached frame {}. Target was {}. Unblocking", frame_idx,
                 target_frame_num);
    cv_waiting_for_target_frame.notify_one();
  }
}

void SlippiPlaybackStatus::resetPlayback()
{
  if (should_run_threads)
  {
    should_run_threads = false;

    if (m_savestate_thread.joinable())
      m_savestate_thread.detach();

    cond_var.notify_one();  // Will allow thread to kill itself
    future_diffs.clear();
    future_diffs.rehash(0);
  }

  should_jump_back = false;
  should_jump_forward = false;
  is_hard_FFW = false;
  is_soft_FFW = false;
  target_frame_num = INT_MAX;
  in_slippi_playback = false;
}

void SlippiPlaybackStatus::processInitialState(Core::System& system)
{
  INFO_LOG_FMT(SLIPPI, "saving initial_state");
  State::SaveToBuffer(system, initial_state);
  // The initial save to curr_state causes a stutter of about 5-10 frames
  // Doing it here to get it out of the way and prevent stutters later
  // Subsequent calls to SaveToBuffer for curr_state take ~1 frame
  State::SaveToBuffer(system, curr_state);
  if (Config::Get(Config::SLIPPI_ENABLE_SEEK))
  {
    Config::SetCurrent(Config::MAIN_SHOW_CURSOR, Config::ShowCursor::Constantly);
  }
};

void SlippiPlaybackStatus::SavestateThread()
{
  Core::System& system = Core::System::GetInstance();
  Common::SetCurrentThreadName("Savestate thread");
  std::unique_lock<std::mutex> interval_lock(mtx);

  INFO_LOG_FMT(SLIPPI, "Entering savestate thread");

  while (should_run_threads)
  {
    // Wait to hit one of the intervals
    // Possible while rewinding that we hit this wait again.
    while (should_run_threads &&
           (current_playback_frame - Slippi::PLAYBACK_FIRST_SAVE) % FRAME_INTERVAL != 0)
      cond_var.wait(interval_lock);

    if (!should_run_threads)
      break;

    s32 fixed_frame_num = current_playback_frame;
    if (fixed_frame_num == INT_MAX)
      continue;

    bool is_start_frame = fixed_frame_num == Slippi::PLAYBACK_FIRST_SAVE;
    bool has_state_been_processed = future_diffs.count(fixed_frame_num) > 0;

    if (!in_slippi_playback && is_start_frame)
    {
      processInitialState(system);
      in_slippi_playback = true;
    }
    else if (Config::Get(Config::SLIPPI_ENABLE_SEEK) && !has_state_been_processed &&
             !is_start_frame)
    {
      INFO_LOG_FMT(SLIPPI, "saving diff at frame: {}", fixed_frame_num);
      State::SaveToBuffer(system, curr_state);

      future_diffs[fixed_frame_num] = std::async(processDiff, initial_state, curr_state);
    }
    Common::SleepCurrentThread(SLEEP_TIME_MS);
  }

  INFO_LOG_FMT(SLIPPI, "Exiting savestate thread");
}

void SlippiPlaybackStatus::seekToFrame(Core::System& system)
{
  if (seek_mtx.try_lock())
  {
    if (target_frame_num < Slippi::PLAYBACK_FIRST_SAVE)
      target_frame_num = Slippi::PLAYBACK_FIRST_SAVE;

    if (target_frame_num > last_frame)
    {
      target_frame_num = last_frame;
    }

    std::unique_lock<std::mutex> ffw_lock(ffw_mtx);
    auto replay_comm_settings = g_replay_comm->getSettings();
    if (replay_comm_settings.mode == "queue")
      updateWatchSettingsStartEnd();

    auto prev_state = Core::GetState(system);
    if (prev_state != Core::State::Paused)
      Core::SetState(system, Core::State::Paused);

    s32 closest_state_frame =
        target_frame_num - emod(target_frame_num - Slippi::PLAYBACK_FIRST_SAVE, FRAME_INTERVAL);
    bool is_loading_state_optimal =
        target_frame_num < current_playback_frame || closest_state_frame > current_playback_frame;

    if (is_loading_state_optimal)
    {
      if (closest_state_frame <= Slippi::PLAYBACK_FIRST_SAVE)
      {
        State::LoadFromBuffer(system, initial_state);
      }
      else
      {
        // If this diff exists, load it
        if (future_diffs.count(closest_state_frame) > 0)
        {
          loadState(system, closest_state_frame);
        }
        else if (target_frame_num < current_playback_frame)
        {
          s32 closest_actual_state_frame = closest_state_frame - FRAME_INTERVAL;
          while (closest_actual_state_frame > Slippi::PLAYBACK_FIRST_SAVE &&
                 future_diffs.count(closest_actual_state_frame) == 0)
            closest_actual_state_frame -= FRAME_INTERVAL;
          loadState(system, closest_actual_state_frame);
        }
        else if (target_frame_num > current_playback_frame)
        {
          s32 closest_actual_state_frame = closest_state_frame - FRAME_INTERVAL;
          while (closest_actual_state_frame > current_playback_frame &&
                 future_diffs.count(closest_actual_state_frame) == 0)
            closest_actual_state_frame -= FRAME_INTERVAL;

          // only load a savestate if we find one past our current frame since we are seeking
          // forwards
          if (closest_actual_state_frame > current_playback_frame)
            loadState(system, closest_actual_state_frame);
        }
      }
    }

    // Fastforward until we get to the frame we want
    if (target_frame_num != closest_state_frame && target_frame_num != last_frame)
    {
      setHardFFW(true);
      Core::SetState(system, Core::State::Running);
      cv_waiting_for_target_frame.wait(ffw_lock);
      Core::SetState(system, Core::State::Paused);
      setHardFFW(false);
    }

    // We've reached the frame we want. Reset target_frame_num and release mutex so another seek can
    // be performed
    g_playback_status->current_playback_frame = target_frame_num;
    target_frame_num = INT_MAX;
    Core::SetState(system, prev_state);
    seek_mtx.unlock();
  }
  else
  {
    INFO_LOG_FMT(SLIPPI, "Already seeking. Ignoring this call");
  }
}

// Set is_hard_FFW and update OC settings to speed up the FFW
void SlippiPlaybackStatus::setHardFFW(bool enable)
{
  if (enable)
  {
    SConfig::GetSlippiConfig().oc_enable = true;
    SConfig::GetSlippiConfig().oc_factor = 4.0f;
  }
  else
  {
    SConfig::GetSlippiConfig().oc_factor = orig_OC_factor;
    SConfig::GetSlippiConfig().oc_enable = orig_OC_enable;
  }

  is_hard_FFW = enable;
}

void SlippiPlaybackStatus::loadState(Core::System& system, s32 closest_state_frame)
{
  if (closest_state_frame == Slippi::PLAYBACK_FIRST_SAVE)
    State::LoadFromBuffer(system, initial_state);
  else
  {
    std::string state_string;
    decoder.Decode((char*)initial_state.data(), initial_state.size(),
                   future_diffs[closest_state_frame].get(), &state_string);
    std::vector<u8> state_to_load(state_string.begin(), state_string.end());
    State::LoadFromBuffer(system, state_to_load);
  }
}

bool SlippiPlaybackStatus::shouldFFWFrame(s32 frame_idx) const
{
  if (!is_soft_FFW && !is_hard_FFW)
  {
    // If no FFW at all, don't FFW this frame
    return false;
  }

  if (is_hard_FFW)
  {
    // For a hard FFW, always FFW until it's turned off
    return true;
  }

  // Here we have a soft FFW, we only want to turn on FFW for single frames once
  // every X frames to FFW in a more smooth manner
  return (frame_idx - last_FFW_frame) >= 15;
}

void SlippiPlaybackStatus::updateWatchSettingsStartEnd()
{
  int start_frame = g_replay_comm->current.start_frame;
  int end_frame = g_replay_comm->current.end_frame;
  if (start_frame != Slippi::GAME_FIRST_FRAME || end_frame != INT_MAX)
  {
    if (g_playback_status->target_frame_num < start_frame)
      g_replay_comm->current.start_frame = g_playback_status->target_frame_num;
    if (g_playback_status->target_frame_num > end_frame)
      g_replay_comm->current.end_frame = INT_MAX;
  }
}

std::unordered_map<u32, bool> SlippiPlaybackStatus::getDenylist()
{
  return deny_list;
}

std::vector<u8> SlippiPlaybackStatus::getLegacyCodelist()
{
  return legacy_code_list;
}

inline std::string readString(json obj, std::string key)
{
  auto item = obj.find(key);
  if (item == obj.end() || item.value().is_null())
  {
    return "";
  }

  return obj[key];
}

int getOrderNumFromFileName(std::string name)
{
  // Extract last value after a dash, then try to parse it into a number. This is the
  // number we will sort by. If there is no number present, the number used is 0.
  std::string last;
  std::istringstream f(name);
  std::string s;
  while (std::getline(f, s, '-'))
  {
    last = s;
  }

  int num;
  if (!TryParse(last, &num))
  {
    num = 0;
  }

  return num;
}

// Compares two intervals according to starting times.
bool compareInjectionList(File::FSTEntry i1, File::FSTEntry i2)
{
  return getOrderNumFromFileName(i1.virtualName) < getOrderNumFromFileName(i2.virtualName);
}

void SlippiPlaybackStatus::generateDenylist()
{
  // We start by populating the deny_list with old injections that are not longer used but need
  // to be included for backward compatibility reasons.
  // It also includes some common codes that are not in our codebase
  deny_list = {
      // Backward compatibility
      // Post 3.4.0: Recording/FlushFrameBuffer.asm
      {0x802fef88, true},
      // Post 3.4.0: Recording/SendGamePostFrame.asm
      {0x8006c5d8, true},
      // Post 3.7.0: Recording/SendGameEnd.asm
      {0x8016d30c, true},
      // Online/Menus/InGame/InitInGame.asm
      // https://github.com/project-slippi/slippi-ssbm-asm/blame/7211b1cfe0792e0fa5ebfbac6bb493bda05d8ee2/Online/Menus/InGame/InitInGame.asm
      {0x8016e9b4, true},

      // Common codes not in our codebase
      // HUD Transparency v1.1 (https://smashboards.com/threads/transparent-hud-v1-1.508509/)
      {0x802f6690, true},
      // Smaller "Ready, GO!" (https://smashboards.com/threads/smaller-ready-go.509740/)
      {0x802F71E0, true},
      // Yellow During IASA
      // (https://smashboards.com/threads/color-overlays-for-iasa-frames.401474/post-19120928)
      {0x80071960, true},
      // Turn Green When Actionable (https://blippi.gg/codes)
      {0x800CC818, true},
      {0x8008A478, true},
  };

  // Next we parse through the injection lists files to exclude all of our injections that don't
  // affect gameplay
  std::string injections_path =
      File::GetSysDirectory() + DIR_SEP + "Slippi" + DIR_SEP + "InjectionLists";
  auto entries = File::ScanDirectoryTree(injections_path, false);
  auto children = entries.children;

  // First sort by the file names so later lists take precedence
  std::sort(children.begin(), children.end(), compareInjectionList);

  for (auto& entry : children)
  {
    if (entry.isDirectory)
      continue;

    std::string contents;
    File::ReadFileToString(entry.physicalName, contents);
    auto res = json::parse(contents, nullptr, false);
    if (res.is_discarded() || !res.is_object())
    {
      ERROR_LOG_FMT(SLIPPI, "Injection list file {} is not properly formatted.",
                    entry.physicalName);
      continue;
    }

    auto list = res["Details"];
    if (list.is_discarded() || !list.is_array())
    {
      ERROR_LOG_FMT(SLIPPI, "Injection list file {} is not properly formatted.",
                    entry.physicalName);
      continue;
    }

    // Go through all the injections
    for (auto& injection : list)
    {
      if (injection.is_discarded() || !injection.is_object())
      {
        ERROR_LOG_FMT(SLIPPI, "Injection entry in list file {} is not properly formatted.",
                      entry.physicalName);
        continue;
      }

      // Check if tags indicate that this code affects gameplay, if so, do not put it on the
      // deny_list
      auto tags = readString(injection, "Tags");
      bool should_deny = tags.find("[affects-gameplay]") == std::string::npos;

      // Add injection to deny_list
      u32 address;
      auto address_str = readString(injection, "InjectionAddress");
      if (Common::FromChars(address_str, address, 16).ec != std::errc{})
      {
        ERROR_LOG_FMT(SLIPPI, "Injection list file {}: Could not parse address: {}",
                      entry.physicalName, address_str);
        continue;
      }
      deny_list[address] = should_deny;
      // INFO_LOG(SLIPPI, "New deny_list entry: %08X", address);
    }
  }

  NOTICE_LOG_FMT(SLIPPI, "Denylist populated with length: {}", deny_list.size());
}

void SlippiPlaybackStatus::generateLegacyCodelist()
{
  legacy_code_list = {
      0xC2, 0x0C, 0x9A, 0x44, 0x00, 0x00, 0x00,
      0x2F,  // #External/UCF + Arduino Toggle UI/UCF/UCF 0.74
             // Dashback - Check for Toggle.asm
      0xD0, 0x1F, 0x00, 0x2C, 0x88, 0x9F, 0x06, 0x18, 0x38, 0x62, 0xF2, 0x28, 0x7C, 0x63, 0x20,
      0xAE, 0x2C, 0x03, 0x00, 0x01, 0x41, 0x82, 0x00, 0x14, 0x38, 0x62, 0xF2, 0x2C, 0x7C, 0x63,
      0x20, 0xAE, 0x2C, 0x03, 0x00, 0x01, 0x40, 0x82, 0x01, 0x50, 0x7C, 0x08, 0x02, 0xA6, 0x90,
      0x01, 0x00, 0x04, 0x94, 0x21, 0xFF, 0x50, 0xBE, 0x81, 0x00, 0x08, 0x48, 0x00, 0x01, 0x21,
      0x7F, 0xC8, 0x02, 0xA6, 0xC0, 0x3F, 0x08, 0x94, 0xC0, 0x5E, 0x00, 0x00, 0xFC, 0x01, 0x10,
      0x40, 0x40, 0x82, 0x01, 0x18, 0x80, 0x8D, 0xAE, 0xB4, 0xC0, 0x3F, 0x06, 0x20, 0xFC, 0x20,
      0x0A, 0x10, 0xC0, 0x44, 0x00, 0x3C, 0xFC, 0x01, 0x10, 0x40, 0x41, 0x80, 0x01, 0x00, 0x88,
      0x7F, 0x06, 0x70, 0x2C, 0x03, 0x00, 0x02, 0x40, 0x80, 0x00, 0xF4, 0x88, 0x7F, 0x22, 0x1F,
      0x54, 0x60, 0x07, 0x39, 0x40, 0x82, 0x00, 0xE8, 0x3C, 0x60, 0x80, 0x4C, 0x60, 0x63, 0x1F,
      0x78, 0x8B, 0xA3, 0x00, 0x01, 0x38, 0x7D, 0xFF, 0xFE, 0x88, 0x9F, 0x06, 0x18, 0x48, 0x00,
      0x00, 0x8D, 0x7C, 0x7C, 0x1B, 0x78, 0x7F, 0xA3, 0xEB, 0x78, 0x88, 0x9F, 0x06, 0x18, 0x48,
      0x00, 0x00, 0x7D, 0x7C, 0x7C, 0x18, 0x50, 0x7C, 0x63, 0x19, 0xD6, 0x2C, 0x03, 0x15, 0xF9,
      0x40, 0x81, 0x00, 0xB0, 0x38, 0x00, 0x00, 0x01, 0x90, 0x1F, 0x23, 0x58, 0x90, 0x1F, 0x23,
      0x40, 0x80, 0x9F, 0x00, 0x04, 0x2C, 0x04, 0x00, 0x0A, 0x40, 0xA2, 0x00, 0x98, 0x88, 0x7F,
      0x00, 0x0C, 0x38, 0x80, 0x00, 0x01, 0x3D, 0x80, 0x80, 0x03, 0x61, 0x8C, 0x41, 0x8C, 0x7D,
      0x89, 0x03, 0xA6, 0x4E, 0x80, 0x04, 0x21, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x78,
      0x80, 0x83, 0x00, 0x2C, 0x80, 0x84, 0x1E, 0xCC, 0xC0, 0x3F, 0x00, 0x2C, 0xD0, 0x24, 0x00,
      0x18, 0xC0, 0x5E, 0x00, 0x04, 0xFC, 0x01, 0x10, 0x40, 0x41, 0x81, 0x00, 0x0C, 0x38, 0x60,
      0x00, 0x80, 0x48, 0x00, 0x00, 0x08, 0x38, 0x60, 0x00, 0x7F, 0x98, 0x64, 0x00, 0x06, 0x48,
      0x00, 0x00, 0x48, 0x7C, 0x85, 0x23, 0x78, 0x38, 0x63, 0xFF, 0xFF, 0x2C, 0x03, 0x00, 0x00,
      0x40, 0x80, 0x00, 0x08, 0x38, 0x63, 0x00, 0x05, 0x3C, 0x80, 0x80, 0x46, 0x60, 0x84, 0xB1,
      0x08, 0x1C, 0x63, 0x00, 0x30, 0x7C, 0x84, 0x1A, 0x14, 0x1C, 0x65, 0x00, 0x0C, 0x7C, 0x84,
      0x1A, 0x14, 0x88, 0x64, 0x00, 0x02, 0x7C, 0x63, 0x07, 0x74, 0x4E, 0x80, 0x00, 0x20, 0x4E,
      0x80, 0x00, 0x21, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x81, 0x00, 0x08,
      0x80, 0x01, 0x00, 0xB4, 0x38, 0x21, 0x00, 0xB0, 0x7C, 0x08, 0x03, 0xA6, 0x00, 0x00, 0x00,
      0x00, 0xC2, 0x09, 0x98, 0xA4, 0x00, 0x00, 0x00,
      0x2B,  // #External/UCF + Arduino Toggle UI/UCF/UCF
      // 0.74 Shield Drop - Check for Toggle.asm
      0x7C, 0x08, 0x02, 0xA6, 0x90, 0x01, 0x00, 0x04, 0x94, 0x21, 0xFF, 0x50, 0xBE, 0x81, 0x00,
      0x08, 0x7C, 0x7E, 0x1B, 0x78, 0x83, 0xFE, 0x00, 0x2C, 0x48, 0x00, 0x01, 0x01, 0x7F, 0xA8,
      0x02, 0xA6, 0x88, 0x9F, 0x06, 0x18, 0x38, 0x62, 0xF2, 0x28, 0x7C, 0x63, 0x20, 0xAE, 0x2C,
      0x03, 0x00, 0x01, 0x41, 0x82, 0x00, 0x14, 0x38, 0x62, 0xF2, 0x30, 0x7C, 0x63, 0x20, 0xAE,
      0x2C, 0x03, 0x00, 0x01, 0x40, 0x82, 0x00, 0xF8, 0xC0, 0x3F, 0x06, 0x3C, 0x80, 0x6D, 0xAE,
      0xB4, 0xC0, 0x03, 0x03, 0x14, 0xFC, 0x01, 0x00, 0x40, 0x40, 0x81, 0x00, 0xE4, 0xC0, 0x3F,
      0x06, 0x20, 0x48, 0x00, 0x00, 0x71, 0xD0, 0x21, 0x00, 0x90, 0xC0, 0x3F, 0x06, 0x24, 0x48,
      0x00, 0x00, 0x65, 0xC0, 0x41, 0x00, 0x90, 0xEC, 0x42, 0x00, 0xB2, 0xEC, 0x21, 0x00, 0x72,
      0xEC, 0x21, 0x10, 0x2A, 0xC0, 0x5D, 0x00, 0x0C, 0xFC, 0x01, 0x10, 0x40, 0x41, 0x80, 0x00,
      0xB4, 0x88, 0x9F, 0x06, 0x70, 0x2C, 0x04, 0x00, 0x03, 0x40, 0x81, 0x00, 0xA8, 0xC0, 0x1D,
      0x00, 0x10, 0xC0, 0x3F, 0x06, 0x24, 0xFC, 0x00, 0x08, 0x40, 0x40, 0x80, 0x00, 0x98, 0xBA,
      0x81, 0x00, 0x08, 0x80, 0x01, 0x00, 0xB4, 0x38, 0x21, 0x00, 0xB0, 0x7C, 0x08, 0x03, 0xA6,
      0x80, 0x61, 0x00, 0x1C, 0x83, 0xE1, 0x00, 0x14, 0x38, 0x21, 0x00, 0x18, 0x38, 0x63, 0x00,
      0x08, 0x7C, 0x68, 0x03, 0xA6, 0x4E, 0x80, 0x00, 0x20, 0xFC, 0x00, 0x0A, 0x10, 0xC0, 0x3D,
      0x00, 0x00, 0xEC, 0x00, 0x00, 0x72, 0xC0, 0x3D, 0x00, 0x04, 0xEC, 0x00, 0x08, 0x28, 0xFC,
      0x00, 0x00, 0x1E, 0xD8, 0x01, 0x00, 0x80, 0x80, 0x61, 0x00, 0x84, 0x38, 0x63, 0x00, 0x02,
      0x3C, 0x00, 0x43, 0x30, 0xC8, 0x5D, 0x00, 0x14, 0x6C, 0x63, 0x80, 0x00, 0x90, 0x01, 0x00,
      0x80, 0x90, 0x61, 0x00, 0x84, 0xC8, 0x21, 0x00, 0x80, 0xEC, 0x01, 0x10, 0x28, 0xC0, 0x3D,
      0x00, 0x00, 0xEC, 0x20, 0x08, 0x24, 0x4E, 0x80, 0x00, 0x20, 0x4E, 0x80, 0x00, 0x21, 0x42,
      0xA0, 0x00, 0x00, 0x37, 0x27, 0x00, 0x00, 0x43, 0x30, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00,
      0xBF, 0x4C, 0xCC, 0xCD, 0x43, 0x30, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x7F, 0xC3, 0xF3,
      0x78, 0x7F, 0xE4, 0xFB, 0x78, 0xBA, 0x81, 0x00, 0x08, 0x80, 0x01, 0x00, 0xB4, 0x38, 0x21,
      0x00, 0xB0, 0x7C, 0x08, 0x03, 0xA6, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2,
      0x16, 0xE7, 0x50, 0x00, 0x00, 0x00,
      0x33,  // #Common/StaticPatches/ToggledStaticOverwrites.asm
      0x88, 0x62, 0xF2, 0x34, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 0x48, 0x00, 0x00,
      0x75, 0x7C, 0x68, 0x02, 0xA6, 0x48, 0x00, 0x01, 0x3D, 0x48, 0x00, 0x00, 0x14, 0x48, 0x00,
      0x00, 0x95, 0x7C, 0x68, 0x02, 0xA6, 0x48, 0x00, 0x01, 0x2D, 0x48, 0x00, 0x00, 0x04, 0x88,
      0x62, 0xF2, 0x38, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 0x48, 0x00, 0x00, 0xB9,
      0x7C, 0x68, 0x02, 0xA6, 0x48, 0x00, 0x01, 0x11, 0x48, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00,
      0xC9, 0x7C, 0x68, 0x02, 0xA6, 0x48, 0x00, 0x01, 0x01, 0x88, 0x62, 0xF2, 0x3C, 0x2C, 0x03,
      0x00, 0x00, 0x41, 0x82, 0x00, 0x14, 0x48, 0x00, 0x00, 0xD1, 0x7C, 0x68, 0x02, 0xA6, 0x48,
      0x00, 0x00, 0xE9, 0x48, 0x00, 0x01, 0x04, 0x48, 0x00, 0x00, 0xD1, 0x7C, 0x68, 0x02, 0xA6,
      0x48, 0x00, 0x00, 0xD9, 0x48, 0x00, 0x00, 0xF4, 0x4E, 0x80, 0x00, 0x21, 0x80, 0x3C, 0xE4,
      0xD4, 0x00, 0x24, 0x04, 0x64, 0x80, 0x07, 0x96, 0xE0, 0x60, 0x00, 0x00, 0x00, 0x80, 0x2B,
      0x7E, 0x54, 0x48, 0x00, 0x00, 0x88, 0x80, 0x2B, 0x80, 0x8C, 0x48, 0x00, 0x00, 0x84, 0x80,
      0x12, 0x39, 0xA8, 0x60, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x4E, 0x80, 0x00, 0x21,
      0x80, 0x3C, 0xE4, 0xD4, 0x00, 0x20, 0x00, 0x00, 0x80, 0x07, 0x96, 0xE0, 0x3A, 0x40, 0x00,
      0x01, 0x80, 0x2B, 0x7E, 0x54, 0x88, 0x7F, 0x22, 0x40, 0x80, 0x2B, 0x80, 0x8C, 0x2C, 0x03,
      0x00, 0x02, 0x80, 0x10, 0xFC, 0x48, 0x90, 0x05, 0x21, 0xDC, 0x80, 0x10, 0xFB, 0x68, 0x90,
      0x05, 0x21, 0xDC, 0x80, 0x12, 0x39, 0xA8, 0x90, 0x1F, 0x1A, 0x5C, 0xFF, 0xFF, 0xFF, 0xFF,
      0x4E, 0x80, 0x00, 0x21, 0x80, 0x1D, 0x46, 0x10, 0x48, 0x00, 0x00, 0x4C, 0x80, 0x1D, 0x47,
      0x24, 0x48, 0x00, 0x00, 0x3C, 0x80, 0x1D, 0x46, 0x0C, 0x80, 0x9F, 0x00, 0xEC, 0xFF, 0xFF,
      0xFF, 0xFF, 0x4E, 0x80, 0x00, 0x21, 0x80, 0x1D, 0x46, 0x10, 0x38, 0x83, 0x7F, 0x9C, 0x80,
      0x1D, 0x47, 0x24, 0x88, 0x1B, 0x00, 0xC4, 0x80, 0x1D, 0x46, 0x0C, 0x3C, 0x60, 0x80, 0x3B,
      0xFF, 0xFF, 0xFF, 0xFF, 0x4E, 0x80, 0x00, 0x21, 0x80, 0x1D, 0x45, 0xFC, 0x48, 0x00, 0x09,
      0xDC, 0xFF, 0xFF, 0xFF, 0xFF, 0x4E, 0x80, 0x00, 0x21, 0x80, 0x1D, 0x45, 0xFC, 0x40, 0x80,
      0x09, 0xDC, 0xFF, 0xFF, 0xFF, 0xFF, 0x38, 0xA3, 0xFF, 0xFC, 0x84, 0x65, 0x00, 0x04, 0x2C,
      0x03, 0xFF, 0xFF, 0x41, 0x82, 0x00, 0x10, 0x84, 0x85, 0x00, 0x04, 0x90, 0x83, 0x00, 0x00,
      0x4B, 0xFF, 0xFF, 0xEC, 0x4E, 0x80, 0x00, 0x20, 0x3C, 0x60, 0x80, 0x00, 0x3C, 0x80, 0x00,
      0x3B, 0x60, 0x84, 0x72, 0x2C, 0x3D, 0x80, 0x80, 0x32, 0x61, 0x8C, 0x8F, 0x50, 0x7D, 0x89,
      0x03, 0xA6, 0x4E, 0x80, 0x04, 0x21, 0x3C, 0x60, 0x80, 0x17, 0x3C, 0x80, 0x80, 0x17, 0x00,
      0x00, 0x00, 0x00, 0xC2, 0x1D, 0x14, 0xC8, 0x00, 0x00, 0x00, 0x04,  // #Common/Preload Stadium
      // Transformations/Handlers/Init
      // isLoaded Bool.asm
      0x88, 0x62, 0xF2, 0x38, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0C, 0x38, 0x60, 0x00,
      0x00, 0x98, 0x7F, 0x00, 0xF0, 0x3B, 0xA0, 0x00, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xC2, 0x1D, 0x45, 0xEC, 0x00, 0x00, 0x00, 0x1B,  // #Common/Preload Stadium
      // Transformations/Handlers/Load
      // Transformation.asm
      0x88, 0x62, 0xF2, 0x38, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0xC4, 0x88, 0x7F, 0x00,
      0xF0, 0x2C, 0x03, 0x00, 0x00, 0x40, 0x82, 0x00, 0xB8, 0x38, 0x60, 0x00, 0x04, 0x3D, 0x80,
      0x80, 0x38, 0x61, 0x8C, 0x05, 0x80, 0x7D, 0x89, 0x03, 0xA6, 0x4E, 0x80, 0x04, 0x21, 0x54,
      0x60, 0x10, 0x3A, 0xA8, 0x7F, 0x00, 0xE2, 0x3C, 0x80, 0x80, 0x3B, 0x60, 0x84, 0x7F, 0x9C,
      0x7C, 0x84, 0x00, 0x2E, 0x7C, 0x03, 0x20, 0x00, 0x41, 0x82, 0xFF, 0xD4, 0x90, 0x9F, 0x00,
      0xEC, 0x2C, 0x04, 0x00, 0x03, 0x40, 0x82, 0x00, 0x0C, 0x38, 0x80, 0x00, 0x00, 0x48, 0x00,
      0x00, 0x34, 0x2C, 0x04, 0x00, 0x04, 0x40, 0x82, 0x00, 0x0C, 0x38, 0x80, 0x00, 0x01, 0x48,
      0x00, 0x00, 0x24, 0x2C, 0x04, 0x00, 0x09, 0x40, 0x82, 0x00, 0x0C, 0x38, 0x80, 0x00, 0x02,
      0x48, 0x00, 0x00, 0x14, 0x2C, 0x04, 0x00, 0x06, 0x40, 0x82, 0x00, 0x00, 0x38, 0x80, 0x00,
      0x03, 0x48, 0x00, 0x00, 0x04, 0x3C, 0x60, 0x80, 0x3E, 0x60, 0x63, 0x12, 0x48, 0x54, 0x80,
      0x10, 0x3A, 0x7C, 0x63, 0x02, 0x14, 0x80, 0x63, 0x03, 0xD8, 0x80, 0x9F, 0x00, 0xCC, 0x38,
      0xBF, 0x00, 0xC8, 0x3C, 0xC0, 0x80, 0x1D, 0x60, 0xC6, 0x42, 0x20, 0x38, 0xE0, 0x00, 0x00,
      0x3D, 0x80, 0x80, 0x01, 0x61, 0x8C, 0x65, 0x80, 0x7D, 0x89, 0x03, 0xA6, 0x4E, 0x80, 0x04,
      0x21, 0x38, 0x60, 0x00, 0x01, 0x98, 0x7F, 0x00, 0xF0, 0x80, 0x7F, 0x00, 0xD8, 0x60, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x1D, 0x4F, 0x14, 0x00, 0x00, 0x00,
      0x04,  // #Common/Preload
      // Stadium
      // Transformations/Handlers/Reset
      // isLoaded.asm
      0x88, 0x62, 0xF2, 0x38, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x0C, 0x38, 0x60, 0x00,
      0x00, 0x98, 0x7F, 0x00, 0xF0, 0x80, 0x6D, 0xB2, 0xD8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xC2, 0x06, 0x8F, 0x30, 0x00, 0x00, 0x00,
      0x9D,  // #Common/PAL/Handlers/Character DAT
      // Patcher.asm
      0x88, 0x62, 0xF2, 0x34, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x04, 0xD4, 0x7C, 0x08, 0x02,
      0xA6, 0x90, 0x01, 0x00, 0x04, 0x94, 0x21, 0xFF, 0x50, 0xBE, 0x81, 0x00, 0x08, 0x83, 0xFE,
      0x01, 0x0C, 0x83, 0xFF, 0x00, 0x08, 0x3B, 0xFF, 0xFF, 0xE0, 0x80, 0x7D, 0x00, 0x00, 0x2C,
      0x03, 0x00, 0x1B, 0x40, 0x80, 0x04, 0x9C, 0x48, 0x00, 0x00, 0x71, 0x48, 0x00, 0x00, 0xA9,
      0x48, 0x00, 0x00, 0xB9, 0x48, 0x00, 0x01, 0x51, 0x48, 0x00, 0x01, 0x79, 0x48, 0x00, 0x01,
      0x79, 0x48, 0x00, 0x02, 0x29, 0x48, 0x00, 0x02, 0x39, 0x48, 0x00, 0x02, 0x81, 0x48, 0x00,
      0x02, 0xF9, 0x48, 0x00, 0x03, 0x11, 0x48, 0x00, 0x03, 0x11, 0x48, 0x00, 0x03, 0x11, 0x48,
      0x00, 0x03, 0x11, 0x48, 0x00, 0x03, 0x21, 0x48, 0x00, 0x03, 0x21, 0x48, 0x00, 0x03, 0x89,
      0x48, 0x00, 0x03, 0x89, 0x48, 0x00, 0x03, 0x91, 0x48, 0x00, 0x03, 0x91, 0x48, 0x00, 0x03,
      0xA9, 0x48, 0x00, 0x03, 0xA9, 0x48, 0x00, 0x03, 0xB9, 0x48, 0x00, 0x03, 0xB9, 0x48, 0x00,
      0x03, 0xC9, 0x48, 0x00, 0x03, 0xC9, 0x48, 0x00, 0x03, 0xC9, 0x48, 0x00, 0x04, 0x29, 0x7C,
      0x88, 0x02, 0xA6, 0x1C, 0x63, 0x00, 0x04, 0x7C, 0x84, 0x1A, 0x14, 0x80, 0xA4, 0x00, 0x00,
      0x54, 0xA5, 0x01, 0xBA, 0x7C, 0xA4, 0x2A, 0x14, 0x80, 0x65, 0x00, 0x00, 0x80, 0x85, 0x00,
      0x04, 0x2C, 0x03, 0x00, 0xFF, 0x41, 0x82, 0x00, 0x14, 0x7C, 0x63, 0xFA, 0x14, 0x90, 0x83,
      0x00, 0x00, 0x38, 0xA5, 0x00, 0x08, 0x4B, 0xFF, 0xFF, 0xE4, 0x48, 0x00, 0x03, 0xF0, 0x00,
      0x00, 0x33, 0x44, 0x3F, 0x54, 0x7A, 0xE1, 0x00, 0x00, 0x33, 0x60, 0x42, 0xC4, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x37, 0x9C, 0x42, 0x92, 0x00, 0x00, 0x00, 0x00, 0x39,
      0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x0C, 0x40, 0x86, 0x66, 0x66, 0x00, 0x00,
      0x39, 0x10, 0x3D, 0xEA, 0x0E, 0xA1, 0x00, 0x00, 0x39, 0x28, 0x41, 0xA0, 0x00, 0x00, 0x00,
      0x00, 0x3C, 0x04, 0x2C, 0x01, 0x48, 0x0C, 0x00, 0x00, 0x47, 0x20, 0x1B, 0x96, 0x80, 0x13,
      0x00, 0x00, 0x47, 0x34, 0x1B, 0x96, 0x80, 0x13, 0x00, 0x00, 0x47, 0x3C, 0x04, 0x00, 0x00,
      0x09, 0x00, 0x00, 0x4A, 0x40, 0x2C, 0x00, 0x68, 0x11, 0x00, 0x00, 0x4A, 0x4C, 0x28, 0x1B,
      0x00, 0x13, 0x00, 0x00, 0x4A, 0x50, 0x0D, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x4A, 0x54, 0x2C,
      0x80, 0x68, 0x11, 0x00, 0x00, 0x4A, 0x60, 0x28, 0x1B, 0x00, 0x13, 0x00, 0x00, 0x4A, 0x64,
      0x0D, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x4B, 0x24, 0x2C, 0x00, 0x68, 0x0D, 0x00, 0x00, 0x4B,
      0x30, 0x0F, 0x10, 0x40, 0x13, 0x00, 0x00, 0x4B, 0x38, 0x2C, 0x80, 0x38, 0x0D, 0x00, 0x00,
      0x4B, 0x44, 0x0F, 0x10, 0x40, 0x13, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x38, 0x0C, 0x00,
      0x00, 0x00, 0x07, 0x00, 0x00, 0x4E, 0xF8, 0x2C, 0x00, 0x38, 0x03, 0x00, 0x00, 0x4F, 0x08,
      0x0F, 0x80, 0x00, 0x0B, 0x00, 0x00, 0x4F, 0x0C, 0x2C, 0x80, 0x20, 0x03, 0x00, 0x00, 0x4F,
      0x1C, 0x0F, 0x80, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
      0x4D, 0x10, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x70, 0x42, 0x94, 0x00, 0x00, 0x00,
      0x00, 0x4D, 0xD4, 0x41, 0x90, 0x00, 0x00, 0x00, 0x00, 0x4D, 0xE0, 0x41, 0x90, 0x00, 0x00,
      0x00, 0x00, 0x83, 0xAC, 0x2C, 0x00, 0x00, 0x09, 0x00, 0x00, 0x83, 0xB8, 0x34, 0x8C, 0x80,
      0x11, 0x00, 0x00, 0x84, 0x00, 0x34, 0x8C, 0x80, 0x11, 0x00, 0x00, 0x84, 0x30, 0x05, 0x00,
      0x00, 0x8B, 0x00, 0x00, 0x84, 0x38, 0x04, 0x1A, 0x05, 0x00, 0x00, 0x00, 0x84, 0x44, 0x05,
      0x00, 0x00, 0x8B, 0x00, 0x00, 0x84, 0xDC, 0x05, 0x78, 0x05, 0x78, 0x00, 0x00, 0x85, 0xB8,
      0x10, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x85, 0xC0, 0x03, 0xE8, 0x01, 0xF4, 0x00, 0x00, 0x85,
      0xCC, 0x10, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x85, 0xD4, 0x03, 0x84, 0x03, 0xE8, 0x00, 0x00,
      0x85, 0xE0, 0x10, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x88, 0x18, 0x0B, 0x00, 0x01, 0x0B, 0x00,
      0x00, 0x88, 0x2C, 0x0B, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x88, 0xF8, 0x04, 0x1A, 0x0B, 0xB8,
      0x00, 0x00, 0x89, 0x3C, 0x04, 0x1A, 0x0B, 0xB8, 0x00, 0x00, 0x89, 0x80, 0x04, 0x1A, 0x0B,
      0xB8, 0x00, 0x00, 0x89, 0xE0, 0x04, 0xFE, 0xF7, 0x04, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
      0x36, 0xCC, 0x42, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x37, 0xC4, 0x0C, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0xFF, 0x00, 0x00, 0x34, 0x68, 0x3F, 0x66, 0x66, 0x66, 0x00, 0x00, 0x39, 0xD8,
      0x44, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x44, 0xB4, 0x99, 0x00, 0x11, 0x00, 0x00, 0x3A,
      0x48, 0x1B, 0x8C, 0x00, 0x8F, 0x00, 0x00, 0x3A, 0x58, 0xB4, 0x99, 0x00, 0x11, 0x00, 0x00,
      0x3A, 0x5C, 0x1B, 0x8C, 0x00, 0x8F, 0x00, 0x00, 0x3A, 0x6C, 0xB4, 0x99, 0x00, 0x11, 0x00,
      0x00, 0x3A, 0x70, 0x1B, 0x8C, 0x00, 0x8F, 0x00, 0x00, 0x3B, 0x30, 0x44, 0x0C, 0x00, 0x00,
      0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x45, 0xC8, 0x2C, 0x01, 0x50, 0x10, 0x00, 0x00, 0x45,
      0xD4, 0x2D, 0x19, 0x80, 0x13, 0x00, 0x00, 0x45, 0xDC, 0x2C, 0x80, 0xB0, 0x10, 0x00, 0x00,
      0x45, 0xE8, 0x2D, 0x19, 0x80, 0x13, 0x00, 0x00, 0x49, 0xC4, 0x2C, 0x00, 0x68, 0x0A, 0x00,
      0x00, 0x49, 0xD0, 0x28, 0x1B, 0x80, 0x13, 0x00, 0x00, 0x49, 0xD8, 0x2C, 0x80, 0x78, 0x0A,
      0x00, 0x00, 0x49, 0xE4, 0x28, 0x1B, 0x80, 0x13, 0x00, 0x00, 0x49, 0xF0, 0x2C, 0x00, 0x68,
      0x08, 0x00, 0x00, 0x49, 0xFC, 0x23, 0x1B, 0x80, 0x13, 0x00, 0x00, 0x4A, 0x04, 0x2C, 0x80,
      0x78, 0x08, 0x00, 0x00, 0x4A, 0x10, 0x23, 0x1B, 0x80, 0x13, 0x00, 0x00, 0x5C, 0x98, 0x1E,
      0x0C, 0x80, 0x80, 0x00, 0x00, 0x5C, 0xF4, 0xB4, 0x80, 0x0C, 0x90, 0x00, 0x00, 0x5D, 0x08,
      0xB4, 0x80, 0x0C, 0x90, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x3A, 0x1C, 0xB4, 0x94, 0x00,
      0x13, 0x00, 0x00, 0x3A, 0x64, 0x2C, 0x00, 0x00, 0x15, 0x00, 0x00, 0x3A, 0x70, 0xB4, 0x92,
      0x80, 0x13, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
      0x00, 0x00, 0xFF, 0x00, 0x00, 0x64, 0x7C, 0xB4, 0x9A, 0x40, 0x17, 0x00, 0x00, 0x64, 0x80,
      0x64, 0x00, 0x10, 0x97, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x33,
      0xE4, 0x42, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x45, 0x28, 0x2C, 0x01, 0x30, 0x11, 0x00, 0x00,
      0x45, 0x34, 0xB4, 0x98, 0x80, 0x13, 0x00, 0x00, 0x45, 0x3C, 0x2C, 0x81, 0x30, 0x11, 0x00,
      0x00, 0x45, 0x48, 0xB4, 0x98, 0x80, 0x13, 0x00, 0x00, 0x45, 0x50, 0x2D, 0x00, 0x20, 0x11,
      0x00, 0x00, 0x45, 0x5C, 0xB4, 0x98, 0x80, 0x13, 0x00, 0x00, 0x45, 0xF8, 0x2C, 0x01, 0x30,
      0x0F, 0x00, 0x00, 0x46, 0x08, 0x0F, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x46, 0x0C, 0x2C, 0x81,
      0x28, 0x0F, 0x00, 0x00, 0x46, 0x1C, 0x0F, 0x00, 0x01, 0x0B, 0x00, 0x00, 0x4A, 0xEC, 0x2C,
      0x00, 0x70, 0x03, 0x00, 0x00, 0x4B, 0x00, 0x2C, 0x80, 0x38, 0x03, 0x00, 0x00, 0x00, 0xFF,
      0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x48, 0x5C, 0x2C, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
      0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x37, 0xB0, 0x3F, 0x59, 0x99, 0x9A, 0x00, 0x00,
      0x37, 0xCC, 0x42, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x55, 0x20, 0x87, 0x11, 0x80, 0x13, 0x00,
      0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x3B, 0x8C, 0x44, 0x0C, 0x00, 0x00,
      0x00, 0x00, 0x3D, 0x0C, 0x44, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
      0xFF, 0x00, 0x00, 0x50, 0xE4, 0xB4, 0x99, 0x00, 0x13, 0x00, 0x00, 0x50, 0xF8, 0xB4, 0x99,
      0x00, 0x13, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
      0x00, 0x4E, 0xB0, 0x02, 0xBC, 0xFF, 0x38, 0x00, 0x00, 0x4E, 0xBC, 0x14, 0x00, 0x01, 0x23,
      0x00, 0x00, 0x4E, 0xC4, 0x03, 0x84, 0x01, 0xF4, 0x00, 0x00, 0x4E, 0xD0, 0x14, 0x00, 0x01,
      0x23, 0x00, 0x00, 0x4E, 0xD8, 0x04, 0x4C, 0x04, 0xB0, 0x00, 0x00, 0x4E, 0xE4, 0x14, 0x00,
      0x01, 0x23, 0x00, 0x00, 0x50, 0x5C, 0x2C, 0x00, 0x68, 0x15, 0x00, 0x00, 0x50, 0x6C, 0x14,
      0x08, 0x01, 0x23, 0x00, 0x00, 0x50, 0x70, 0x2C, 0x80, 0x60, 0x15, 0x00, 0x00, 0x50, 0x80,
      0x14, 0x08, 0x01, 0x23, 0x00, 0x00, 0x50, 0x84, 0x2D, 0x00, 0x20, 0x15, 0x00, 0x00, 0x50,
      0x94, 0x14, 0x08, 0x01, 0x23, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xBA, 0x81,
      0x00, 0x08, 0x80, 0x01, 0x00, 0xB4, 0x38, 0x21, 0x00, 0xB0, 0x7C, 0x08, 0x03, 0xA6, 0x3C,
      0x60, 0x80, 0x3C, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x2F, 0x9A, 0x3C,
      0x00, 0x00, 0x00, 0x08,  // #Common/PAL/Handlers/PAL Stock Icons.asm
      0x88, 0x62, 0xF2, 0x34, 0x2C, 0x03, 0x00, 0x00, 0x41, 0x82, 0x00, 0x30, 0x48, 0x00, 0x00,
      0x21, 0x7C, 0x88, 0x02, 0xA6, 0x80, 0x64, 0x00, 0x00, 0x90, 0x7D, 0x00, 0x2C, 0x90, 0x7D,
      0x00, 0x30, 0x80, 0x64, 0x00, 0x04, 0x90, 0x7D, 0x00, 0x3C, 0x48, 0x00, 0x00, 0x10, 0x4E,
      0x80, 0x00, 0x21, 0x3F, 0x59, 0x99, 0x9A, 0xC1, 0xA8, 0x00, 0x00, 0x80, 0x1D, 0x00, 0x14,
      0x00, 0x00, 0x00, 0x00, 0xC2, 0x10, 0xFC, 0x44, 0x00, 0x00, 0x00,
      0x04,  // #Common/PAL/Handlers/DK
      // Up B/Aerial Up B.asm
      0x88, 0x82, 0xF2, 0x34, 0x2C, 0x04, 0x00, 0x00, 0x41, 0x82, 0x00, 0x10, 0x3C, 0x00, 0x80,
      0x11, 0x60, 0x00, 0x00, 0x74, 0x48, 0x00, 0x00, 0x08, 0x38, 0x03, 0xD7, 0x74, 0x00, 0x00,
      0x00, 0x00, 0xC2, 0x10, 0xFB, 0x64, 0x00, 0x00, 0x00,
      0x04,  // #Common/PAL/Handlers/DK Up B/Grounded
      // Up B.asm
      0x88, 0x82, 0xF2, 0x34, 0x2C, 0x04, 0x00, 0x00, 0x41, 0x82, 0x00, 0x10, 0x3C, 0x00, 0x80,
      0x11, 0x60, 0x00, 0x00, 0x74, 0x48, 0x00, 0x00, 0x08, 0x38, 0x03, 0xD7, 0x74, 0x00, 0x00,
      0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // Termination sequence
  };
}

SlippiPlaybackStatus::~SlippiPlaybackStatus()
{
  // Kill threads to prevent cleanup crash
  resetPlayback();
}
