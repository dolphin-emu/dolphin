// Copyright 2018 Dolphin Emulator Project
// Licensed under GPLv2+
// Refer to the license.txt file included.

#include <OptionParser.h>
#include <bitset>
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <variant>
#include <vector>

struct Instruction
{
  std::vector<std::string> cells;
};

struct SubTable
{
  std::string name;
};

struct StartTableMarker
{
  std::string name;
  int shift;
  int length;
  std::string description;
};
struct Empty
{
};

using InputLine = std::variant<Instruction, SubTable, StartTableMarker, Empty>;

constexpr char SEPARATOR = ';';

enum
{
  OPID_RANGES = 1,
  DECODING_TABLE = 2,
  OPNAME_TABLE = 4,
};

struct ColumnOptions
{
  unsigned int column;
  std::string prefix;
  std::string suffix;
  std::string default_value;
};

struct OutputOptions
{
  int flags = 0;
  std::vector<ColumnOptions> columns;
};

struct DecodingEntry
{
  std::string table_name;
  std::string description;
  std::bitset<64> instructions;
  std::bitset<64> subtables;
  size_t instruction_offset = 0;
  size_t subtable_offset = 0;
  int shift = 0;
  int length = 0;
  DecodingEntry(std::string name) : table_name(std::move(name)) {}
};

static void CreateTable(std::vector<Instruction>& table, std::vector<DecodingEntry>& decoding_table,
                        size_t current_entry_offset, const std::vector<InputLine>& lines)
{
  DecodingEntry& entry = decoding_table.at(current_entry_offset);
  entry.instruction_offset = table.size();
  // offset is relative and displaced by one, to simplify (and serve as termination proof of)
  // GetOpID. This cannot underflow, because current_entry_offset must be a valid index into
  // decoding_table.
  entry.subtable_offset = decoding_table.size() - current_entry_offset - 1;
  std::vector<size_t> subtables;
  size_t start = 0;
  while (true)
  {
    if (start == lines.size())
    {
      std::cerr << "Error: subtable \"" << entry.table_name << "\" not found\n";
      std::exit(1);
    }
    if (std::holds_alternative<StartTableMarker>(lines[start]))
    {
      auto& marker = std::get<StartTableMarker>(lines[start]);
      if (marker.name == entry.table_name)
      {
        start += 1;
        entry.description = marker.description;
        entry.shift = marker.shift;
        entry.length = marker.length;
        break;
      }
    }
    start += 1;
  }
  size_t end;
  for (end = start; end < lines.size() && end - start < (static_cast<size_t>(1) << entry.length) &&
                    !std::holds_alternative<StartTableMarker>(lines[end]);
       end += 1)
  {
    entry.instructions <<= 1;
    entry.subtables <<= 1;
    if (std::holds_alternative<Instruction>(lines[end]))
    {
      table.push_back(std::get<Instruction>(lines[end]));
      entry.instructions |= 1;
    }
    else if (std::holds_alternative<SubTable>(lines[end]))
    {
      subtables.push_back(end);
      entry.subtables |= 1;
    }
  }
  if (end - start == (static_cast<size_t>(1) << entry.length))
  {
    for (size_t i = end; i < lines.size() && !std::holds_alternative<StartTableMarker>(lines[i]);
         i += 1)
    {
      if (!std::holds_alternative<Empty>(lines[i]))
      {
        std::cerr << "Error: subtable \"" << entry.table_name << "\" (" << entry.length
                  << "-bit field) is longer than " << (1 << entry.length) << "\n";
        std::exit(1);
      }
    }
  }
  entry.instructions <<= 64 + start - end;
  entry.subtables <<= 64 + start - end;
  const size_t offset = entry.subtable_offset;
  for (auto& i : subtables)
  {
    // WARNING: may invalidate 'entry'
    decoding_table.push_back(DecodingEntry(std::get<SubTable>(lines[i]).name));
  }
  for (size_t i = 0; i < subtables.size(); i += 1)
  {
    CreateTable(table, decoding_table, current_entry_offset + offset + 1 + i, lines);
  }
}

static void DoOutput(const std::vector<Instruction>& table,
                     const std::vector<DecodingEntry>& decoding_table, const OutputOptions& options,
                     std::ostream& out)
{
  if ((options.flags & OPID_RANGES) || (options.flags & DECODING_TABLE) || !options.columns.empty())
  {
    out << "// Code generated by TableGen.cpp; DO NOT EDIT.\n// clang-format off\n";
  }
  if (options.flags & OPID_RANGES)
  {
    for (auto& dec : decoding_table)
    {
      out << dec.table_name << " = " << dec.instruction_offset + 1 << ", // " << dec.description
          << "\n";
      out << dec.table_name << "_End = " << dec.instruction_offset + 1 + dec.instructions.count()
          << ",\n";
    }
    out << "End = " << table.size() + 1 << '\n';
  }
  if (options.flags & DECODING_TABLE)
  {
    for (auto& dec : decoding_table)
    {
      out << "{0b" << dec.instructions << ", 0b" << dec.subtables << ", "
          << dec.instruction_offset + 1 << ", " << dec.subtable_offset << ", " << dec.shift << ", "
          << dec.length << "},\n";
    }
  }
  if (!options.columns.empty())
  {
    for (auto& inst : table)
    {
      if (options.columns.size() > 1)
      {
        out << "{";
      }
      for (auto& col : options.columns)
      {
        if (inst.cells.size() <= col.column || inst.cells[col.column].empty())
        {
          if (col.default_value == "*")
          {
            out << col.prefix << inst.cells.at(0) << col.suffix << ", ";
          }
          else
          {
            out << col.default_value << ", ";
          }
        }
        else if (inst.cells[col.column] == "*")
        {
          out << col.prefix << inst.cells[0] << col.suffix << ", ";
        }
        else
        {
          out << col.prefix << inst.cells[col.column] << col.suffix << ", ";
        }
      }
      if (options.columns.size() > 1)
      {
        out << "},";
      }
      out << '\n';
    }
  }
  if ((options.flags & OPID_RANGES) || (options.flags & DECODING_TABLE) || !options.columns.empty())
  {
    out << "    // clang-format on\n";
  }
}

static void ReadTable(std::istream& in, std::vector<std::vector<std::string>>& rows)
{
  std::string line;
  while (std::getline(in, line))
  {
    std::vector<std::string> row;
    std::istringstream line_stream(line);
    std::string cell;
    while (std::getline(line_stream, cell, SEPARATOR))
    {
      row.push_back(cell);
    }
    rows.push_back(std::move(row));
  }
}

// F is an (anonymous) lambda type
template <class F>
class FunctionCallback : public optparse::Callback
{
private:
  F func;

public:
  FunctionCallback(F function) : func(function) {}
  void operator()(const optparse::Option& option, const std::string& opt, const std::string& val,
                  const optparse::OptionParser& parser)
  {
    func(option, opt, val, parser);
  }
};

static void ParseCommandLine(int argc, char** argv, OutputOptions& stdout_options,
                             std::vector<std::pair<std::ofstream, OutputOptions>>& file_outputs,
                             std::string& inputfile)
{
  optparse::OptionParser parser =
      optparse::OptionParser()
          .usage("usage: %prog [options]")
          .version("%prog\n"
                   "Copyright 2018 Dolphin Emulator Project\n"
                   "Licensed under GPLv2+")
          .description(
              "Generates decoding, dispatch and information tables from a csv-based format");
  parser.add_option("-i", "--input")
      .type("string")
      .action("store")
      .dest("input")
      .set_default("")
      .help("read from this file, not stdin");
  auto output = FunctionCallback(
      [&stdout_options, &file_outputs](const optparse::Option&, const std::string&,
                                       const std::string& val, const optparse::OptionParser&) {
        file_outputs.emplace_back(std::ofstream(val), stdout_options);
        stdout_options = OutputOptions();
      });
  parser.add_option("-o", "--output")
      .action("callback")
      .type("string")
      .callback(output)
      .help(
          "sets an output file for the preceding options. Trailing options are applied for stdout");
  auto ranges = FunctionCallback(
      [&stdout_options](const optparse::Option&, const std::string&, const std::string&,
                        const optparse::OptionParser&) { stdout_options.flags |= OPID_RANGES; });
  parser.add_option("-r", "--opid-ranges")
      .action("callback")
      .callback(ranges)
      .help("generate OpID range definition");
  auto decoding = FunctionCallback(
      [&stdout_options](const optparse::Option&, const std::string&, const std::string&,
                        const optparse::OptionParser&) { stdout_options.flags |= DECODING_TABLE; });
  parser.add_option("-D", "--decoding-table")
      .action("callback")
      .callback(decoding)
      .help("generate a decoding table");
  auto column =
      FunctionCallback([&stdout_options](const optparse::Option&, const std::string&,
                                         const std::string& val, const optparse::OptionParser&) {
        std::cout << val << "\n";
        int value = std::stoi(val);
        if (value < 0)
        {
          std::cerr << "Column indices must not be negative.\n";
          std::exit(1);
        }
        stdout_options.columns.emplace_back(
            ColumnOptions{static_cast<unsigned int>(value), "", "", ""});
      });
  parser.add_option("-c", "--column")
      .action("callback")
      .type("int")
      .nargs(1)
      .callback(column)
      .help("generate a custom (dispatch) table. Add the specified column.");
  auto prefix =
      FunctionCallback([&stdout_options](const optparse::Option&, const std::string&,
                                         const std::string& val, const optparse::OptionParser&) {
        stdout_options.columns.back().prefix = val;
      });
  parser.add_option("-p", "--prefix")
      .action("callback")
      .type("string")
      .nargs(1)
      .callback(prefix)
      .help("set the prefix for the previously-defined column.");
  auto suffix =
      FunctionCallback([&stdout_options](const optparse::Option&, const std::string&,
                                         const std::string& val, const optparse::OptionParser&) {
        stdout_options.columns.back().suffix = val;
      });
  parser.add_option("-s", "--suffix")
      .action("callback")
      .type("string")
      .nargs(1)
      .callback(suffix)
      .help("set the suffix for the previously-defined column.");
  auto default_value =
      FunctionCallback([&stdout_options](const optparse::Option&, const std::string&,
                                         const std::string& val, const optparse::OptionParser&) {
        stdout_options.columns.back().default_value = val;
      });
  parser.add_option("-d", "--default")
      .action("callback")
      .type("string")
      .nargs(1)
      .callback(default_value)
      .help("set the default value for the previously-defined column. If the default value is "
            "used, prefix and suffix are not used. If the value given here is '*' (beware shell "
            "escaping) an empty value will be processed as if it had been the same as the opname "
            "in the first place (prefix and suffix are applied).");

  auto options = parser.parse_args(argc, argv);
  inputfile = options["input"];
}

static std::vector<InputLine> ParseTableToLines(const std::vector<std::vector<std::string>> rows)
{
  std::vector<InputLine> lines;
  for (auto& row : rows)
  {
    if (!row.empty())
    {
      const std::string& opname = row.front();
      if (opname == "->")
      {
        if (row.size() < 1)
        {
          std::cerr << "Error: not enough cells for subtable reference in line "
                    << (lines.size() + 1) << '\n';
          std::exit(1);
        }
        lines.push_back(SubTable{row[1]});
      }
      else if (opname == "===")
      {
        if (row.size() < 4)
        {
          std::cerr << "Error: not enough cells for subtable marker in line " << (lines.size() + 1)
                    << '\n';
          std::exit(1);
        }
        int shift = std::stoi(row[2]);
        int len = std::stoi(row[3]);
        if (len > 6 || len < 1)
        {
          std::cerr << "Error: field for table \"" << row[1] << "\" is not 1â€“6 bits in line "
                    << (lines.size() + 1) << '\n';
          std::exit(1);
        }
        if (shift > 32 - len || shift < 0)
        {
          std::cerr << "Error: field for table \"" << row[1]
                    << "\" has invalid shift value in line " << (lines.size() + 1) << '\n';
          std::exit(1);
        }
        lines.push_back(StartTableMarker{row[1], shift, len, row[4]});
      }
      else if (opname.empty() || opname == "#")
      {
        // used for comments, treat as empty line
        lines.push_back(Empty());
      }
      else
      {
        lines.push_back(Instruction{std::move(row)});
      }
    }
    else
    {
      lines.push_back(Empty());
    }
  }
  return lines;
}

int main(int argc, char** argv)
{
  std::vector<std::pair<std::ofstream, OutputOptions>> file_outputs;
  OutputOptions stdout_options;
  std::string inputfile;
  ParseCommandLine(argc, argv, stdout_options, file_outputs, inputfile);
  std::vector<std::vector<std::string>> rows;
  if (inputfile.empty())
  {
    ReadTable(std::cin, rows);
  }
  else
  {
    auto file = std::ifstream(inputfile);
    ReadTable(file, rows);
  }
  auto lines = ParseTableToLines(std::move(rows));
  std::vector<Instruction> table;
  std::vector<DecodingEntry> decoding_table;
  decoding_table.push_back(DecodingEntry("Primary"));
  CreateTable(table, decoding_table, 0, lines);
  DoOutput(table, decoding_table, stdout_options, std::cout);
  for (auto& pair : file_outputs)
  {
    DoOutput(table, decoding_table, pair.second, pair.first);
  }
}
